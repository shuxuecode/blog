<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.funimg.top</id>
    <title>学无止境的博客</title>
    <updated>2022-04-14T02:47:03.514Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.funimg.top"/>
    <link rel="self" href="https://blog.funimg.top/atom.xml"/>
    <subtitle>学无止境</subtitle>
    <logo>https://blog.funimg.top/images/avatar.png</logo>
    <icon>https://blog.funimg.top/favicon.ico</icon>
    <rights>All rights reserved 2022, 学无止境的博客</rights>
    <entry>
        <title type="html"><![CDATA[SpringBean系列]]></title>
        <id>https://blog.funimg.top/post/springbean-xi-lie/</id>
        <link href="https://blog.funimg.top/post/springbean-xi-lie/">
        </link>
        <updated>2022-04-14T02:46:25.000Z</updated>
        <content type="html"><![CDATA[<p>生命周期</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[中秋节快乐]]></title>
        <id>https://blog.funimg.top/post/zhong-qiu-jie-kuai-le/</id>
        <link href="https://blog.funimg.top/post/zhong-qiu-jie-kuai-le/">
        </link>
        <updated>2021-09-17T14:47:19.000Z</updated>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java面试问答——多线程]]></title>
        <id>https://blog.funimg.top/post/java-mian-shi-wen-da-duo-xian-cheng/</id>
        <link href="https://blog.funimg.top/post/java-mian-shi-wen-da-duo-xian-cheng/">
        </link>
        <updated>2021-05-24T17:43:47.000Z</updated>
        <content type="html"><![CDATA[<h2 id="什么是线程">什么是线程？</h2>
<p>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位，可以使用多线程对进行运算提速。</p>
<h2 id="创建线程池有几种方式">创建线程池有几种方式？</h2>
<ul>
<li>继承Thread类</li>
<li>实现Runnable接口，重写run（）方法</li>
<li>实现Callable接口，覆写call（）方法，有返回值</li>
<li>使用线程池创建</li>
</ul>
<h2 id="java自带的线程池有哪些">Java自带的线程池有哪些？</h2>
<ul>
<li>newCachedThreadPool，可缓存线程池</li>
<li>newFixedThreadPool，创建一个指定工作线程数量的线程池</li>
<li>newSingleThreadExecutor，单工作线程最大的特点是可保证顺序地执行各个任务</li>
<li>newScheduleThreadPool，创建一个定长的线程池，支持定时及周期性任务执行。</li>
</ul>
<h2 id="说说线程池的拒绝策略">说说线程池的拒绝策略</h2>
<ul>
<li>AbortPolicy策略：该策略会直接抛出异常，阻止系统正常工作。</li>
<li>CallerRunsPolicy 策略：只要线程池未关闭，该策略直接在调用者线程中，运行当前的被丢弃的任务。</li>
<li>DiscardOleddestPolicy策略： 该策略将丢弃最老的一个请求，也就是即将被执行的任务，并尝试再次提交当前任务。</li>
<li>DiscardPolicy策略：该策略默默的丢弃无法处理的任务，不予任何处理。</li>
</ul>
<p>除了JDK默认为什么提供的四种拒绝策略，我们可以根据自己的业务需求去自定义拒绝策略，自定义的方式很简单，直接实现RejectedExecutionHandler接口即可。</p>
<blockquote>
<p>比如Spring integration中就有一个自定义的拒绝策略CallerBlocksPolicy，将任务插入到队列中，直到队列中有空闲并插入成功的时候，否则将根据最大等待时间一直阻塞，直到超时。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[祝大家520节日快乐]]></title>
        <id>https://blog.funimg.top/post/zhu-da-jia-520-jie-ri-kuai-le/</id>
        <link href="https://blog.funimg.top/post/zhu-da-jia-520-jie-ri-kuai-le/">
        </link>
        <updated>2021-05-20T04:30:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id=""></h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot的自动装配机制]]></title>
        <id>https://blog.funimg.top/post/springboot-de-zi-dong-zhuang-pei-ji-zhi/</id>
        <link href="https://blog.funimg.top/post/springboot-de-zi-dong-zhuang-pei-ji-zhi/">
        </link>
        <updated>2021-04-27T15:28:36.000Z</updated>
        <content type="html"><![CDATA[<h2 id="mark">mark</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[开工大吉，牛年牛气冲天]]></title>
        <id>https://blog.funimg.top/post/kai-gong-da-ji-niu-nian-niu-qi-chong-tian/</id>
        <link href="https://blog.funimg.top/post/kai-gong-da-ji-niu-nian-niu-qi-chong-tian/">
        </link>
        <updated>2021-02-18T04:05:07.000Z</updated>
        <content type="html"><![CDATA[<p>加油</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[祝大家元旦快乐]]></title>
        <id>https://blog.funimg.top/post/zhu-da-jia-yuan-dan-kuai-le/</id>
        <link href="https://blog.funimg.top/post/zhu-da-jia-yuan-dan-kuai-le/">
        </link>
        <updated>2021-01-01T10:12:49.000Z</updated>
        <content type="html"><![CDATA[<p>再见。2020<br>
你好，2021</p>
<figure data-type="image" tabindex="1"><img src="https://blog.funimg.top/post-images/1609496053212.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[祝大家中秋节国庆节快乐]]></title>
        <id>https://blog.funimg.top/post/zhu-da-jia-zhong-qiu-jie-guo-qing-jie-kuai-le/</id>
        <link href="https://blog.funimg.top/post/zhu-da-jia-zhong-qiu-jie-guo-qing-jie-kuai-le/">
        </link>
        <updated>2020-10-01T13:38:31.000Z</updated>
        <content type="html"><![CDATA[<p>㊗️朋友们双节快乐</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Electron的安装与使用]]></title>
        <id>https://blog.funimg.top/post/pei-zhi/</id>
        <link href="https://blog.funimg.top/post/pei-zhi/">
        </link>
        <updated>2020-09-03T15:51:01.000Z</updated>
        <content type="html"><![CDATA[<h2 id="全局安装-electron">全局安装 Electron</h2>
<p>npm install electron -g</p>
<h2 id="打包">打包</h2>
<h3 id="全局安装打包神器electron-packager">全局安装打包神器electron-packager</h3>
<p>npm install electron-packager -g</p>
<h4 id="最简打包">最简打包</h4>
<p>electron-packager .</p>
<p>打包成功，在当前目录下生成一个新的文件夹，里面生成一堆文件，点击其中的exe，即可启动桌面程序：</p>
<pre><code>electron-packager . &lt;可执行文件的文件名&gt; --win --out &lt;打包成的文件夹名&gt; --arch=&lt;x64位还是32位&gt; --version &lt;版本号&gt; --overwrite --ignore=node_modules
</code></pre>
<h2 id="安装electron-builder">安装electron-builder</h2>
<p>npm install electron-builder -g</p>
<h3 id="打包-2">打包</h3>
<p>electron-builder --win --x64</p>
<p>打包完成在dist目录生成以下文件：</p>
<pre><code>win-unpacked 免安装版
builder-effective-config.yaml 记录打包信息
my-project Setup 0.0.1.exe  安装文件，默认安装在c盘
my-project Setup 0.0.1.exe.blockmap 文件系统索引模式
</code></pre>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hexo搭建博客]]></title>
        <id>https://blog.funimg.top/post/0601/</id>
        <link href="https://blog.funimg.top/post/0601/">
        </link>
        <updated>2020-06-01T15:32:58.000Z</updated>
        <content type="html"><![CDATA[<h2 id="安装hexo">安装Hexo</h2>
<pre><code>npm install hexo-cli -g  
npm install hexo-deployer-git --save  
</code></pre>
<p>第二个命令表示安装 hexo 部署到 git page 的 deployer</p>
<h2 id="hexo初始化">Hexo初始化</h2>
<pre><code>hexo init &lt;folder&gt;
</code></pre>
<h2 id="运行">运行</h2>
<pre><code>hexo g  #生成或 hexo generate  生成的静态文件在 /***/public 目录下 
hexo d  #启动本地服务器 或者 hexo server,这一步之后就可以通过http://localhost:4000 查看了
</code></pre>
<h2 id="配置">配置</h2>
<p>官网文档：<br>
<a href="https://hexo.io/zh-cn/docs/configuration">https://hexo.io/zh-cn/docs/configuration</a></p>
<h2 id="部署到github">部署到Github</h2>
<blockquote>
<p>找到github的ssh链接</p>
</blockquote>
<p>打开文件夹下的 _config.yml 文件</p>
<pre><code>deploy: 
    type: git
    repository: git@github.om:XXX.git
    branch: master
</code></pre>
<p>执行 <code>hexo g -d</code> 就会部署到github上了。</p>
<h2 id="新建文章">新建文章</h2>
<pre><code>hexo n &quot;文章标题&quot;

hexo new &quot;文章名&quot; #新建文章
hexo new page &quot;页面名&quot; #新建页面 
</code></pre>
<p>会在项目 <code>\Hexo\source\_posts</code> 中生成 文章标题.md 文件，<br>
也可以直接在 <code>\Hexo\source\_posts</code> 目录下右键鼠标新建文本文档，改后缀为 .md 即可，这种方法比较方便。</p>
<h2 id="更换主题">更换主题</h2>
<p>https://hexo.io/themes/</p>
<p>把下载的主题文件夹<code>hexo-theme-aero-dual</code>放到 themes 目录下即可。<br>
打开<code>_config.yml</code>配置文件，修改参数为：theme：hexo-theme-aero-dual （其他主题修改成相应名称即可）</p>
<h2 id="使用next主题">使用Next主题</h2>
<p>https://theme-next.org/<br>
https://github.com/theme-next</p>
<h3 id="主题安装">主题安装</h3>
<pre><code>cd hexo   # 进入博客根目录
git clone https://github.com/theme-next/hexo-theme-next themes/next
</code></pre>
<p>Set theme in main Hexo root config _config.yml file:</p>
<pre><code>theme: next
</code></pre>
<h3 id="next配置">Next配置</h3>
<p>编辑 <code>/***/themes/next/_config.yml</code>（其中***为博客根目录）文件</p>
<h2 id="配置域名">配置域名</h2>
<p>编辑CNAME文件，内容为域名</p>
<pre><code>常用简写

hexo n == hexo new
hexo g == hexo generate
hexo s == hexo server
hexo d == hexo deploy
</code></pre>
<p>参考文章：</p>
<ul>
<li>https://blog.csdn.net/qq_36759224/article/details/82121420</li>
</ul>
<hr>
]]></content>
    </entry>
</feed>