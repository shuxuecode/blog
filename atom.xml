<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.funimg.top</id>
    <title>学无止境的博客</title>
    <updated>2022-03-30T14:22:55.826Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.funimg.top"/>
    <link rel="self" href="https://blog.funimg.top/atom.xml"/>
    <subtitle>学无止境</subtitle>
    <logo>https://blog.funimg.top/images/avatar.png</logo>
    <icon>https://blog.funimg.top/favicon.ico</icon>
    <rights>All rights reserved 2022, 学无止境的博客</rights>
    <entry>
        <title type="html"><![CDATA[中秋节快乐]]></title>
        <id>https://blog.funimg.top/post/zhong-qiu-jie-kuai-le/</id>
        <link href="https://blog.funimg.top/post/zhong-qiu-jie-kuai-le/">
        </link>
        <updated>2021-09-17T14:47:19.000Z</updated>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java面试问答——多线程]]></title>
        <id>https://blog.funimg.top/post/java-mian-shi-wen-da-duo-xian-cheng/</id>
        <link href="https://blog.funimg.top/post/java-mian-shi-wen-da-duo-xian-cheng/">
        </link>
        <updated>2021-05-24T17:43:47.000Z</updated>
        <content type="html"><![CDATA[<h2 id="什么是线程">什么是线程？</h2>
<p>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位，可以使用多线程对进行运算提速。</p>
<h2 id="创建线程池有几种方式">创建线程池有几种方式？</h2>
<ul>
<li>继承Thread类</li>
<li>实现Runnable接口，重写run（）方法</li>
<li>实现Callable接口，覆写call（）方法，有返回值</li>
<li>使用线程池创建</li>
</ul>
<h2 id="java自带的线程池有哪些">Java自带的线程池有哪些？</h2>
<ul>
<li>newCachedThreadPool，可缓存线程池</li>
<li>newFixedThreadPool，创建一个指定工作线程数量的线程池</li>
<li>newSingleThreadExecutor，单工作线程最大的特点是可保证顺序地执行各个任务</li>
<li>newScheduleThreadPool，创建一个定长的线程池，支持定时及周期性任务执行。</li>
</ul>
<h2 id="说说线程池的拒绝策略">说说线程池的拒绝策略</h2>
<ul>
<li>AbortPolicy策略：该策略会直接抛出异常，阻止系统正常工作。</li>
<li>CallerRunsPolicy 策略：只要线程池未关闭，该策略直接在调用者线程中，运行当前的被丢弃的任务。</li>
<li>DiscardOleddestPolicy策略： 该策略将丢弃最老的一个请求，也就是即将被执行的任务，并尝试再次提交当前任务。</li>
<li>DiscardPolicy策略：该策略默默的丢弃无法处理的任务，不予任何处理。</li>
</ul>
<p>除了JDK默认为什么提供的四种拒绝策略，我们可以根据自己的业务需求去自定义拒绝策略，自定义的方式很简单，直接实现RejectedExecutionHandler接口即可。</p>
<blockquote>
<p>比如Spring integration中就有一个自定义的拒绝策略CallerBlocksPolicy，将任务插入到队列中，直到队列中有空闲并插入成功的时候，否则将根据最大等待时间一直阻塞，直到超时。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[祝大家520节日快乐]]></title>
        <id>https://blog.funimg.top/post/zhu-da-jia-520-jie-ri-kuai-le/</id>
        <link href="https://blog.funimg.top/post/zhu-da-jia-520-jie-ri-kuai-le/">
        </link>
        <updated>2021-05-20T04:30:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id=""></h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot的自动装配机制]]></title>
        <id>https://blog.funimg.top/post/springboot-de-zi-dong-zhuang-pei-ji-zhi/</id>
        <link href="https://blog.funimg.top/post/springboot-de-zi-dong-zhuang-pei-ji-zhi/">
        </link>
        <updated>2021-04-27T15:28:36.000Z</updated>
        <content type="html"><![CDATA[<h2 id="mark">mark</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[开工大吉，牛年牛气冲天]]></title>
        <id>https://blog.funimg.top/post/kai-gong-da-ji-niu-nian-niu-qi-chong-tian/</id>
        <link href="https://blog.funimg.top/post/kai-gong-da-ji-niu-nian-niu-qi-chong-tian/">
        </link>
        <updated>2021-02-18T04:05:07.000Z</updated>
        <content type="html"><![CDATA[<p>加油</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[祝大家元旦快乐]]></title>
        <id>https://blog.funimg.top/post/zhu-da-jia-yuan-dan-kuai-le/</id>
        <link href="https://blog.funimg.top/post/zhu-da-jia-yuan-dan-kuai-le/">
        </link>
        <updated>2021-01-01T10:12:49.000Z</updated>
        <content type="html"><![CDATA[<p>再见。2020<br>
你好，2021</p>
<figure data-type="image" tabindex="1"><img src="https://blog.funimg.top/post-images/1609496053212.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[祝大家中秋节国庆节快乐]]></title>
        <id>https://blog.funimg.top/post/zhu-da-jia-zhong-qiu-jie-guo-qing-jie-kuai-le/</id>
        <link href="https://blog.funimg.top/post/zhu-da-jia-zhong-qiu-jie-guo-qing-jie-kuai-le/">
        </link>
        <updated>2020-10-01T13:38:31.000Z</updated>
        <content type="html"><![CDATA[<p>㊗️朋友们双节快乐</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Electron的安装与使用]]></title>
        <id>https://blog.funimg.top/post/pei-zhi/</id>
        <link href="https://blog.funimg.top/post/pei-zhi/">
        </link>
        <updated>2020-09-03T15:51:01.000Z</updated>
        <content type="html"><![CDATA[<h2 id="全局安装-electron">全局安装 Electron</h2>
<p>npm install electron -g</p>
<h2 id="打包">打包</h2>
<h3 id="全局安装打包神器electron-packager">全局安装打包神器electron-packager</h3>
<p>npm install electron-packager -g</p>
<h4 id="最简打包">最简打包</h4>
<p>electron-packager .</p>
<p>打包成功，在当前目录下生成一个新的文件夹，里面生成一堆文件，点击其中的exe，即可启动桌面程序：</p>
<pre><code>electron-packager . &lt;可执行文件的文件名&gt; --win --out &lt;打包成的文件夹名&gt; --arch=&lt;x64位还是32位&gt; --version &lt;版本号&gt; --overwrite --ignore=node_modules
</code></pre>
<h2 id="安装electron-builder">安装electron-builder</h2>
<p>npm install electron-builder -g</p>
<h3 id="打包-2">打包</h3>
<p>electron-builder --win --x64</p>
<p>打包完成在dist目录生成以下文件：</p>
<pre><code>win-unpacked 免安装版
builder-effective-config.yaml 记录打包信息
my-project Setup 0.0.1.exe  安装文件，默认安装在c盘
my-project Setup 0.0.1.exe.blockmap 文件系统索引模式
</code></pre>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hexo搭建博客]]></title>
        <id>https://blog.funimg.top/post/0601/</id>
        <link href="https://blog.funimg.top/post/0601/">
        </link>
        <updated>2020-06-01T15:32:58.000Z</updated>
        <content type="html"><![CDATA[<h2 id="安装hexo">安装Hexo</h2>
<pre><code>npm install hexo-cli -g  
npm install hexo-deployer-git --save  
</code></pre>
<p>第二个命令表示安装 hexo 部署到 git page 的 deployer</p>
<h2 id="hexo初始化">Hexo初始化</h2>
<pre><code>hexo init &lt;folder&gt;
</code></pre>
<h2 id="运行">运行</h2>
<pre><code>hexo g  #生成或 hexo generate  生成的静态文件在 /***/public 目录下 
hexo d  #启动本地服务器 或者 hexo server,这一步之后就可以通过http://localhost:4000 查看了
</code></pre>
<h2 id="配置">配置</h2>
<p>官网文档：<br>
<a href="https://hexo.io/zh-cn/docs/configuration">https://hexo.io/zh-cn/docs/configuration</a></p>
<h2 id="部署到github">部署到Github</h2>
<blockquote>
<p>找到github的ssh链接</p>
</blockquote>
<p>打开文件夹下的 _config.yml 文件</p>
<pre><code>deploy: 
    type: git
    repository: git@github.om:XXX.git
    branch: master
</code></pre>
<p>执行 <code>hexo g -d</code> 就会部署到github上了。</p>
<h2 id="新建文章">新建文章</h2>
<pre><code>hexo n &quot;文章标题&quot;

hexo new &quot;文章名&quot; #新建文章
hexo new page &quot;页面名&quot; #新建页面 
</code></pre>
<p>会在项目 <code>\Hexo\source\_posts</code> 中生成 文章标题.md 文件，<br>
也可以直接在 <code>\Hexo\source\_posts</code> 目录下右键鼠标新建文本文档，改后缀为 .md 即可，这种方法比较方便。</p>
<h2 id="更换主题">更换主题</h2>
<p>https://hexo.io/themes/</p>
<p>把下载的主题文件夹<code>hexo-theme-aero-dual</code>放到 themes 目录下即可。<br>
打开<code>_config.yml</code>配置文件，修改参数为：theme：hexo-theme-aero-dual （其他主题修改成相应名称即可）</p>
<h2 id="使用next主题">使用Next主题</h2>
<p>https://theme-next.org/<br>
https://github.com/theme-next</p>
<h3 id="主题安装">主题安装</h3>
<pre><code>cd hexo   # 进入博客根目录
git clone https://github.com/theme-next/hexo-theme-next themes/next
</code></pre>
<p>Set theme in main Hexo root config _config.yml file:</p>
<pre><code>theme: next
</code></pre>
<h3 id="next配置">Next配置</h3>
<p>编辑 <code>/***/themes/next/_config.yml</code>（其中***为博客根目录）文件</p>
<h2 id="配置域名">配置域名</h2>
<p>编辑CNAME文件，内容为域名</p>
<pre><code>常用简写

hexo n == hexo new
hexo g == hexo generate
hexo s == hexo server
hexo d == hexo deploy
</code></pre>
<p>参考文章：</p>
<ul>
<li>https://blog.csdn.net/qq_36759224/article/details/82121420</li>
</ul>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[解决VUE开发过程中跨域的一种解决方案]]></title>
        <id>https://blog.funimg.top/post/jie-jue-vue-kai-fa-guo-cheng-zhong-kua-yu-de-yi-chong-jie-jue-fang-an/</id>
        <link href="https://blog.funimg.top/post/jie-jue-vue-kai-fa-guo-cheng-zhong-kua-yu-de-yi-chong-jie-jue-fang-an/">
        </link>
        <updated>2020-04-18T13:41:50.000Z</updated>
        <content type="html"><![CDATA[<p>前端开发需要调用后台接口时经常遇到跨域的问题，一般是设置Chrome浏览器禁用安全模式，<br>
在启动chrome命令后面加 <code>--disable-web-security</code>，最新的版本可能还需要加一个本地的存放chrome配置的文件夹，如下，<br>
<code>--user-data-dir=C:\MyChromeDevUserData</code></p>
<p>这种方式很不错，唯一的缺点就是有时候如果不是这种方式打开的Chrome，页面要进行跨域调试时需要关闭浏览器再用上边那种方式打开才行，这时如果已经打开了一堆网页可能就比较麻烦了。</p>
<hr>
<p>现在介绍使用Nginx的方向代理机制来解决浏览器跨域的问题</p>
<p>首先假设前端VUE的端口是8080， 要调用的后台接口是：http://192.168.1.111:9090/mydemo/api/getList</p>
<p>因为浏览器的同源策略，所以这样必然产生了跨域。</p>
<p>由于VUE已经占用了前端的端口8080了，所以我们用Nginx只能再设置一个新的端口，这里暂定：8888</p>
<p>在nginx.conf文件 http{} 块里，添加下面的代码：</p>
<pre><code>    server {
        listen  8888;
        server_name  localhost;

        location ^~/mydemo/ {
            rewrite ^/(.*)$ /$1 break;
            proxy_pass http://192.168.1.111:9090/mydemo/;
        }

        location / {
            proxy_pass http://127.0.0.1:8080;
        }
    }
</code></pre>
<h3 id="location-~mydemo-一定要放在-location-前面这样所有访问后台的请求才会走这块的代理-一般后台服务都会带着项目名例如mydemo或者加上固定的url路径前缀主要是为了跟前端静态资源区分开来"><code>location ^~/mydemo/</code> 一定要放在 <code>location /</code> 前面，这样所有访问后台的请求才会走这块的代理。 一般后台服务都会带着项目名，例如<code>mydemo</code>，或者加上固定的url路径前缀，主要是为了跟前端静态资源区分开来。</h3>
<p>重启Nginx，访问 http://localhost:8888 即可。<br>
这样就完全避免了跨域的问题，而且不限于Chrome了，使用IE、Firefox同样没有问题。</p>
<h1 id="下面提供一种新的解决方式">下面提供一种新的解决方式</h1>
<h2 id="什么是跨域">什么是跨域</h2>
<p>跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对JavaScript实施的安全限制。</p>
<h2 id="那么什么是同源策略">那么什么是同源策略</h2>
<p>同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指&quot;协议+域名+端口&quot;三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p>
<p>下面列出了一些常见跨域场景</p>
<p>URL                                      说明                    是否允许通信<br>
http://www.google.com/a.js<br>
http://www.google.com/b.js         同一域名，不同文件或路径           允许<br>
http://www.google.com/lab/c.js</p>
<p>http://www.google.com:8000/a.js<br>
http://www.google.com/b.js         同一域名，不同端口                不允许</p>
<p>http://www.google.com/a.js<br>
https://www.google.com/b.js        同一域名，不同协议                不允许</p>
<p>http://www.google.com/a.js<br>
http://192.168.1.111/b.js           域名和域名对应相同ip              不允许</p>
<p>http://www.google.com/a.js<br>
http://x.google.com/b.js           主域相同，子域不同                不允许<br>
http://google.com/c.js</p>
<p>http://www.domain1.com/a.js<br>
http://www.domain2.com/b.js        不同域名                         不允许</p>
<p>针对跨域，目前有很多解决方案</p>
<p>1、 通过jsonp跨域<br>
2、 document.domain + iframe跨域<br>
3、 location.hash + iframe<br>
4、 window.name + iframe跨域<br>
5、 postMessage跨域<br>
6、 跨域资源共享（CORS）<br>
7、 nginx代理跨域<br>
8、 nodejs中间件代理跨域<br>
9、 WebSocket协议跨域</p>
<p>下面我们就介绍一种目前主流的跨域解决方案——跨域资源共享（CORS）</p>
<h2 id="什么是cors">什么是CORS</h2>
<p>CORS是一个W3C标准，全称是&quot;跨域资源共享&quot;（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。<br>
CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。IE8+：IE8/9需要使用XDomainRequest对象来支持CORS。<br>
整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p>
<h2 id="后端配置">后端配置</h2>
<p>只需要配置一个过滤器即可，如下：</p>
<pre><code>import org.apache.commons.lang3.StringUtils;
import org.springframework.core.annotation.Order;

import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebFilter(urlPatterns = &quot;/*&quot;, filterName = &quot;corsFilter&quot;)
@Order(1)
public class CorsFilter implements Filter {

    @Override
    public void doFilter(ServletRequest req, ServletResponse resp,
                         FilterChain chain) throws IOException, ServletException {
        HttpServletResponse response = (HttpServletResponse) resp;
        HttpServletRequest request = (HttpServletRequest) req;
        // 解决跨域问题
        if (StringUtils.isNotEmpty(request.getHeader(&quot;Origin&quot;))) {
            response.setHeader(&quot;Access-Control-Allow-Origin&quot;, request.getHeader(&quot;Origin&quot;));
            response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);
        } else {
            response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);
        }
        response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS, DELETE&quot;);
        response.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;36000&quot;);
        response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;accept,Access-Control-Request-Method,Access-Control-Request-Headers,Origin,token,x-requested-with, authorization, Content-Type, Authorization, credential, X-XSRF-TOKEN&quot;);
        response.setHeader(&quot;Access-Control-Expose-Headers&quot;, &quot;Content-Type, Authorization, credential, Content-Disposition&quot;);
        if (&quot;OPTIONS&quot;.equalsIgnoreCase(request.getMethod())) {
            response.setStatus(HttpServletResponse.SC_OK);
        } else {
            chain.doFilter(req, resp);
        }
    }

}


</code></pre>
<h2 id="前端配置">前端配置</h2>
<p>前端配置只需要把withCredentials设置为true即可。</p>
<p>1.原生ajax</p>
<pre><code>xhr.withCredentials = true;
</code></pre>
<p>2.vue框架</p>
<p>a.) axios设置：</p>
<pre><code>// 前端设置是否带cookie
axios.defaults.withCredentials = true
</code></pre>
<p>b.) vue-resource设置：</p>
<pre><code>Vue.http.options.credentials = true
</code></pre>
<p>这里假设后端服务地址为： 192.168.1.111:8080</p>
<p>我们需要配置一下hosts，（域名随便写）</p>
<pre><code>192.168.1.111 server.google.com
</code></pre>
<p>这样访问 http://server.google.com:8080 也可能访问到你的后端服务了。</p>
<p>那么前端调用后端接口需要都写成 http://server.google.com:8080/+接口 这样的方式</p>
<p>访问前端也要用这种域名加端口的方式，比如本地启动了前端项目，端口是9090，那么也需要配置一下hosts，</p>
<pre><code>127.0.0.1 front.google.com
</code></pre>
<p>就可以直接用 http://front.google.com:9090 访问前端页面了</p>
<p>也可以用下面这种配置方式直接设定vue启动后访问的url地址。</p>
<pre><code>module.exports = {
  dev: {
    host: 'front.google.com', // can be overwritten by process.env.HOST
    port: 80, // can be overwritten by process.env.PORT, if port is in use, a free one will be determined
    ...
  }
}
</code></pre>
<h2 id="总结一下">总结一下</h2>
<p>1、配置hosts</p>
<pre><code># 后端地址
192.168.1.111 server.google.com
# 前端地址
127.0.0.1 front.google.com
</code></pre>
<p>2、前端调用后端接口需要用域名+端口方式，例如 http://server.google.com:8080</p>
<p>3、在浏览器访问前端页面也需要用域名+端口的方式，例如 http://front.google.com</p>
<p>4、只要保证配置的两个域名的二级域名一样就可以了，三级域名随便。</p>
<p>5、这种方式只需要配置一次，如果想访问不同环境的后端服务，只需要修改hosts配置就可以了。而且部署前后端分离时，只需要修改前端调用后端接口的配置即可。</p>
]]></content>
    </entry>
</feed>